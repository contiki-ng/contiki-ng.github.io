<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Contiki-NG: The Contiki/uIP interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doc-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Contiki-NG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">The Contiki/uIP interface<div class="ingroups"><a class="el" href="group__net.html">IoT networking</a> &raquo; <a class="el" href="group__net-layer.html">Network layer</a> &raquo; <a class="el" href="group__uip.html">uIP: the IPv6 stack</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga41aa744caa46913b3b3aedb2a4e78546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga41aa744caa46913b3b3aedb2a4e78546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga41aa744caa46913b3b3aedb2a4e78546">UIP_APPCALL</a>&#160;&#160;&#160;tcpip_uipcall</td></tr>
<tr class="memdesc:ga41aa744caa46913b3b3aedb2a4e78546"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the application function that uIP should call in response to TCP/IP events. <br /></td></tr>
<tr class="separator:ga41aa744caa46913b3b3aedb2a4e78546"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3e1d02b632991947fdf381d334afdbf2"><td class="memItemLeft" align="right" valign="top">process_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga3e1d02b632991947fdf381d334afdbf2">tcpip_event</a></td></tr>
<tr class="memdesc:ga3e1d02b632991947fdf381d334afdbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The uIP event.  <a href="#ga3e1d02b632991947fdf381d334afdbf2">More...</a><br /></td></tr>
<tr class="separator:ga3e1d02b632991947fdf381d334afdbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
TCP functions</h2></td></tr>
<tr class="memitem:ga5aa80b7b3933f863ed6de1f9b4af8909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga5aa80b7b3933f863ed6de1f9b4af8909">tcp_attach</a> (struct <a class="el" href="structuip__conn.html">uip_conn</a> *conn, void *appstate)</td></tr>
<tr class="memdesc:ga5aa80b7b3933f863ed6de1f9b4af8909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a TCP connection to the current process.  <a href="#ga5aa80b7b3933f863ed6de1f9b4af8909">More...</a><br /></td></tr>
<tr class="separator:ga5aa80b7b3933f863ed6de1f9b4af8909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72945b7277142fdd59b1851eb4f5bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gaf72945b7277142fdd59b1851eb4f5bc1">tcp_listen</a> (uint16_t port)</td></tr>
<tr class="memdesc:gaf72945b7277142fdd59b1851eb4f5bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP port.  <a href="#gaf72945b7277142fdd59b1851eb4f5bc1">More...</a><br /></td></tr>
<tr class="separator:gaf72945b7277142fdd59b1851eb4f5bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga247fe4befbb835e4075c33a74ae0741c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga247fe4befbb835e4075c33a74ae0741c">tcp_unlisten</a> (uint16_t port)</td></tr>
<tr class="memdesc:ga247fe4befbb835e4075c33a74ae0741c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a listening TCP port.  <a href="#ga247fe4befbb835e4075c33a74ae0741c">More...</a><br /></td></tr>
<tr class="separator:ga247fe4befbb835e4075c33a74ae0741c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29fff471983895969bb68c57fb89397"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structuip__conn.html">uip_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gaf29fff471983895969bb68c57fb89397">tcp_connect</a> (const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:gaf29fff471983895969bb68c57fb89397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a TCP connection to the specified IP address and port.  <a href="#gaf29fff471983895969bb68c57fb89397">More...</a><br /></td></tr>
<tr class="separator:gaf29fff471983895969bb68c57fb89397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga7ba71f5f4d459854a5b1e09e6d77b252">tcpip_poll_tcp</a> (struct <a class="el" href="structuip__conn.html">uip_conn</a> *conn)</td></tr>
<tr class="memdesc:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified TCP connection to be polled.  <a href="#ga7ba71f5f4d459854a5b1e09e6d77b252">More...</a><br /></td></tr>
<tr class="separator:ga7ba71f5f4d459854a5b1e09e6d77b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga228f0c0f1c20d43a7fda39b3b8f0fd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga228f0c0f1c20d43a7fda39b3b8f0fd4c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_markconn</b>(conn,  appstate)&#160;&#160;&#160;<a class="el" href="group__tcpip.html#ga5aa80b7b3933f863ed6de1f9b4af8909">tcp_attach</a>(conn, appstate)</td></tr>
<tr class="separator:ga228f0c0f1c20d43a7fda39b3b8f0fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UDP functions</h2></td></tr>
<tr class="memitem:ga3cb4f212906fc7b8909a3f8938006470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga3cb4f212906fc7b8909a3f8938006470">udp_attach</a> (struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *conn, void *appstate)</td></tr>
<tr class="memdesc:ga3cb4f212906fc7b8909a3f8938006470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the current process to a UDP connection.  <a href="#ga3cb4f212906fc7b8909a3f8938006470">More...</a><br /></td></tr>
<tr class="separator:ga3cb4f212906fc7b8909a3f8938006470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50d09ad4a7c853480f694068137f2d30"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga50d09ad4a7c853480f694068137f2d30">udp_new</a> (const uip_ipaddr_t *ripaddr, uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:ga50d09ad4a7c853480f694068137f2d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP connection.  <a href="#ga50d09ad4a7c853480f694068137f2d30">More...</a><br /></td></tr>
<tr class="separator:ga50d09ad4a7c853480f694068137f2d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd0394436a6f855ec38871cacd01f8c9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gabd0394436a6f855ec38871cacd01f8c9">udp_broadcast_new</a> (uint16_t port, void *appstate)</td></tr>
<tr class="memdesc:gabd0394436a6f855ec38871cacd01f8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new UDP broadcast connection.  <a href="#gabd0394436a6f855ec38871cacd01f8c9">More...</a><br /></td></tr>
<tr class="separator:gabd0394436a6f855ec38871cacd01f8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad192daa61c45e0e52bd8a3acb90e48f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gad192daa61c45e0e52bd8a3acb90e48f9">tcpip_poll_udp</a> (struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *conn)</td></tr>
<tr class="memdesc:gad192daa61c45e0e52bd8a3acb90e48f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cause a specified UDP connection to be polled.  <a href="#gad192daa61c45e0e52bd8a3acb90e48f9">More...</a><br /></td></tr>
<tr class="separator:gad192daa61c45e0e52bd8a3acb90e48f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22b8211f05d7e2ef4d521274d07191e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga22b8211f05d7e2ef4d521274d07191e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udp_markconn</b>(conn,  appstate)&#160;&#160;&#160;<a class="el" href="group__tcpip.html#ga3cb4f212906fc7b8909a3f8938006470">udp_attach</a>(conn, appstate)</td></tr>
<tr class="separator:ga22b8211f05d7e2ef4d521274d07191e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afb919d5d0923a55252eeb46caf58d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga6afb919d5d0923a55252eeb46caf58d6">udp_bind</a>(conn,  port)&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#gaa20812098a4663c8a9fc4ce8e95391b6">uip_udp_bind</a>(conn, port)</td></tr>
<tr class="memdesc:ga6afb919d5d0923a55252eeb46caf58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a UDP connection to a local port.  <a href="#ga6afb919d5d0923a55252eeb46caf58d6">More...</a><br /></td></tr>
<tr class="separator:ga6afb919d5d0923a55252eeb46caf58d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ICMPv6 functions</h2></td></tr>
<tr class="memitem:gada1a3e7375e1c1f67e8d7be54a53f419"><td class="memItemLeft" align="right" valign="top">process_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gada1a3e7375e1c1f67e8d7be54a53f419">tcpip_icmp6_event</a></td></tr>
<tr class="memdesc:gada1a3e7375e1c1f67e8d7be54a53f419"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ICMP6 event.  <a href="#gada1a3e7375e1c1f67e8d7be54a53f419">More...</a><br /></td></tr>
<tr class="separator:gada1a3e7375e1c1f67e8d7be54a53f419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac223d97be4637097cabdd918a4de62d9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gac223d97be4637097cabdd918a4de62d9">icmp6_new</a> (void *appstate)</td></tr>
<tr class="memdesc:gac223d97be4637097cabdd918a4de62d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an ICMPv6 callback  <a href="#gac223d97be4637097cabdd918a4de62d9">More...</a><br /></td></tr>
<tr class="separator:gac223d97be4637097cabdd918a4de62d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe99937ca499b4c53084835b7c655e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fe99937ca499b4c53084835b7c655e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga6fe99937ca499b4c53084835b7c655e5">tcpip_icmp6_call</a> (uint8_t type)</td></tr>
<tr class="memdesc:ga6fe99937ca499b4c53084835b7c655e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called at reception of an ICMPv6 packet If an application registered as an ICMPv6 listener (with icmp6_new), it will be called through a <a class="el" href="group__process.html#ga62b7c6efc0e02eaaa067a090d3470f48" title="Post a synchronous event to a process. ">process_post_synch()</a> <br /></td></tr>
<tr class="separator:ga6fe99937ca499b4c53084835b7c655e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
TCP/IP packet processing</h2></td></tr>
<tr class="memitem:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaf7bd597f63c175c2f5e90e10cc67c0c"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a></td></tr>
<tr class="memdesc:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is forwarding generally enabled? <br /></td></tr>
<tr class="separator:gaaf7bd597f63c175c2f5e90e10cc67c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3e06288277302a1fe329b3f68ca953"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9f3e06288277302a1fe329b3f68ca953"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_is_forwarding</b></td></tr>
<tr class="separator:ga9f3e06288277302a1fe329b3f68ca953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a0df258925b212d203559d0604b74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gae8a0df258925b212d203559d0604b74a">tcpip_input</a> (void)</td></tr>
<tr class="memdesc:gae8a0df258925b212d203559d0604b74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deliver an incoming packet to the TCP/IP stack.  <a href="#gae8a0df258925b212d203559d0604b74a">More...</a><br /></td></tr>
<tr class="separator:gae8a0df258925b212d203559d0604b74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e3457ae0795bde06732b071f8f182da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e3457ae0795bde06732b071f8f182da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#ga5e3457ae0795bde06732b071f8f182da">tcpip_output</a> (const <a class="el" href="group__uip.html#ga7583db18ab0411c60c4c1d6ce7bf9af4">uip_lladdr_t</a> *)</td></tr>
<tr class="memdesc:ga5e3457ae0795bde06732b071f8f182da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output packet to layer 2 The eventual parameter is the MAC address of the destination. <br /></td></tr>
<tr class="separator:ga5e3457ae0795bde06732b071f8f182da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3ae7c413a050ec6778b2f9c58dee361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad3ae7c413a050ec6778b2f9c58dee361"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tcpip.html#gad3ae7c413a050ec6778b2f9c58dee361">tcpip_ipv6_output</a> (void)</td></tr>
<tr class="memdesc:gad3ae7c413a050ec6778b2f9c58dee361"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does address resolution and then calls tcpip_output. <br /></td></tr>
<tr class="separator:gad3ae7c413a050ec6778b2f9c58dee361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacccb4e63afa84573fbef8a071dbf8b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacccb4e63afa84573fbef8a071dbf8b5c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>tcpip_set_forwarding</b>(forwarding)&#160;&#160;&#160;<a class="el" href="group__tcpip.html#gaaf7bd597f63c175c2f5e90e10cc67c0c">tcpip_do_forwarding</a> = (forwarding)</td></tr>
<tr class="separator:gacccb4e63afa84573fbef8a071dbf8b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>TCP/IP support in Contiki is implemented using the uIP TCP/IP stack. </p>
<p>For sending and receiving data, Contiki uses the functions provided by the uIP module, but Contiki adds a set of functions for connection management. The connection management functions make sure that the uIP TCP/IP connections are connected to the correct process.</p>
<p>Contiki also includes an optional protosocket library that provides an API similar to the BSD socket API.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__uip.html">The uIP TCP/IP stack</a> </dd>
<dd>
<a class="el" href="group__psock.html">Protosockets library</a> </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6afb919d5d0923a55252eeb46caf58d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udp_bind</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">conn, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group__uipappfunc.html#gaa20812098a4663c8a9fc4ce8e95391b6">uip_udp_bind</a>(conn, port)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a UDP connection to a local port. </p>
<p>This function binds a UDP connection to a specified local port.</p>
<p>When a connection is created with <a class="el" href="group__tcpip.html#ga50d09ad4a7c853480f694068137f2d30" title="Create a new UDP connection. ">udp_new()</a>, it gets a local port number assigned automatically. If the application needs to bind the connection to a specified local port, this function should be used.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="group__uipconvfunc.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order. ">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that is to be bound. </td></tr>
    <tr><td class="paramname">port</td><td>The port number in network byte order to which to bind the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8h_source.html#l00261">261</a> of file <a class="el" href="tcpip_8h_source.html">tcpip.h</a>.</p>

<p>Referenced by <a class="el" href="coap-uip_8c_source.html#l00384">coap_sendto()</a>, <a class="el" href="simple-udp_8c_source.html#l00104">simple_udp_register()</a>, and <a class="el" href="tcpip_8c_source.html#l00279">udp_broadcast_new()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac223d97be4637097cabdd918a4de62d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t icmp6_new </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register an ICMPv6 callback </p>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if failure (one application already registered)</dd></dl>
<p>This function just registers a process to be polled when an ICMPv6 message is received. If no application registers, some ICMPv6 packets will be processed by the "kernel" as usual (NS, NA, RS, RA, Echo request), others will be dropped. If an application registers here, it will be polled with a process_post_synch every time an ICMPv6 packet is received. </p>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00296">296</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip6_8c_source.html#l00263">uip_icmp6_conns</a>.</p>

</div>
</div>
<a class="anchor" id="ga5aa80b7b3933f863ed6de1f9b4af8909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structuip__conn.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a TCP connection to the current process. </p>
<p>This function attaches the current process to a TCP connection. Each TCP connection must be attached to a process in order for the process to be able to receive and send data. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00251">251</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf29fff471983895969bb68c57fb89397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structuip__conn.html">uip_conn</a>* tcp_connect </td>
          <td>(</td>
          <td class="paramtype">const uip_ipaddr_t *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a TCP connection to the specified IP address and port. </p>
<p>This function opens a TCP connection to the specified port at the host specified with an IP address. Additionally, an opaque pointer can be attached to the connection. This pointer will be sent together with uIP events to the process.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="group__uipconvfunc.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order. ">UIP_HTONS()</a> usually is necessary.</dd>
<dd>
This function will only create the connection. The connection is not opened directly. uIP will try to open the connection the next time the uIP stack is scheduled by Contiki.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Referenced by <a class="el" href="tcpip_8c_source.html#l00110">tcpip_output()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf72945b7277142fdd59b1851eb4f5bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_listen </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a TCP port. </p>
<p>This function opens a TCP port for listening. When a TCP connection request occurs for the port, the process will be sent a tcpip_event with the new connection request.</p>
<dl class="section note"><dt>Note</dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="group__uipconvfunc.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order. ">UIP_HTONS()</a> and <a class="el" href="group__uipconvfunc.html#gada74c8133e50b38dca66dbe779395c80" title="Convert a 16-bit quantity from host byte order to network byte order. ">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00233">233</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="process_8h_source.html#l00402">PROCESS_CURRENT</a>, <a class="el" href="uip6_8c_source.html#l00599">uip_listen()</a>, and <a class="el" href="uipopt_8h_source.html#l00399">UIP_LISTENPORTS</a>.</p>

</div>
</div>
<a class="anchor" id="ga247fe4befbb835e4075c33a74ae0741c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcp_unlisten </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a listening TCP port. </p>
<p>This function closes a listening TCP port.</p>
<dl class="section note"><dt>Note</dt><dd>Port numbers must always be given in network byte order. The functions <a class="el" href="group__uipconvfunc.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order. ">UIP_HTONS()</a> and <a class="el" href="group__uipconvfunc.html#gada74c8133e50b38dca66dbe779395c80" title="Convert a 16-bit quantity from host byte order to network byte order. ">uip_htons()</a> can be used to convert port numbers from host byte order to network byte order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number in network byte order. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00215">215</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="process_8h_source.html#l00402">PROCESS_CURRENT</a>, <a class="el" href="uipopt_8h_source.html#l00399">UIP_LISTENPORTS</a>, and <a class="el" href="uip6_8c_source.html#l00587">uip_unlisten()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8a0df258925b212d203559d0604b74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_input </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deliver an incoming packet to the TCP/IP stack. </p>
<p>This function is called by network device drivers to deliver an incoming packet to the TCP/IP stack. The incoming packet must be present in the uip_buf buffer, and the length of the packet must be in the global uip_len variable. </p>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00449">449</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip-nd6_8c_source.html#l00115">addr</a>, <a class="el" href="routing_8h_source.html#l00174">routing_driver::drop_route</a>, <a class="el" href="routing_8h_source.html#l00152">routing_driver::ext_header_srh_get_next_hop</a>, <a class="el" href="uip-icmp6_8h_source.html#l00053">ICMP6_DST_UNREACH</a>, <a class="el" href="uip-icmp6_8h_source.html#l00082">ICMP6_DST_UNREACH_ADDR</a>, <a class="el" href="uip-nd6_8c_source.html#l00114">nbr</a>, <a class="el" href="uip-ds6-nbr_8h_source.html#l00060">NBR_INCOMPLETE</a>, <a class="el" href="process_8c_source.html#l00362">process_post_synch()</a>, <a class="el" href="stimer_8c_source.html#l00067">stimer_set()</a>, <a class="el" href="tcpip_8c_source.html#l00636">tcpip_ipv6_output()</a>, <a class="el" href="tcpip_8c_source.html#l00110">tcpip_output()</a>, <a class="el" href="uip-ds6_8c_source.html#l00075">uip_ds6_if</a>, <a class="el" href="uip-ds6-nbr_8c_source.html#l00074">uip_ds6_nbr_add()</a>, <a class="el" href="uip6_8c_source.html#l00132">uip_ext_len</a>, <a class="el" href="uip-icmp6_8c_source.html#l00174">uip_icmp6_error_output()</a>, <a class="el" href="uip-nd6_8c_source.html#l00096">UIP_IP_BUF</a>, <a class="el" href="uip6_8c_source.html#l00179">uip_len</a>, and <a class="el" href="group__uip.html#ga2af535736966c71dc0c20034c0edad40">uip_nd6_ns_output()</a>.</p>

<p>Referenced by <a class="el" href="sicslowpan_8c_source.html#l01736">input()</a>, and <a class="el" href="arch_2platform_2jn516x_2slip_8c_source.html#l00190">slip_send()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ba71f5f4d459854a5b1e09e6d77b252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_poll_tcp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structuip__conn.html">uip_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a specified TCP connection to be polled. </p>
<p>This function causes uIP to poll the specified TCP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the TCP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00763">763</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip_8h_source.html#l01396">uip_udp_conn::appstate</a>, <a class="el" href="clock_8h_source.html#l00082">CLOCK_SECOND</a>, <a class="el" href="etimer_8c_source.html#l00177">etimer_set()</a>, <a class="el" href="routing_8h_source.html#l00056">routing_driver::init</a>, <a class="el" href="uip_8h_source.html#l01342">uip_conn::lport</a>, <a class="el" href="process_8c_source.html#l00093">process_alloc_event()</a>, <a class="el" href="process_8h_source.html#l00120">PROCESS_BEGIN</a>, <a class="el" href="process_8h_source.html#l00402">PROCESS_CURRENT</a>, <a class="el" href="process_8h_source.html#l00131">PROCESS_END</a>, <a class="el" href="process_8c_source.html#l00322">process_post()</a>, <a class="el" href="process_8c_source.html#l00362">process_post_synch()</a>, <a class="el" href="cc2538-rf_8c_source.html#l01008">PROCESS_THREAD()</a>, <a class="el" href="process_8h_source.html#l00164">PROCESS_YIELD</a>, <a class="el" href="tcpip_8c_source.html#l00066">tcpip_event</a>, <a class="el" href="tcpip_8c_source.html#l00068">tcpip_icmp6_event</a>, <a class="el" href="uip_8h_source.html#l00745">uip_connected</a>, <a class="el" href="uip6_8c_source.html#l00408">uip_init()</a>, and <a class="el" href="uipopt_8h_source.html#l00399">UIP_LISTENPORTS</a>.</p>

<p>Referenced by <a class="el" href="tcpip_8c_source.html#l00110">tcpip_output()</a>.</p>

</div>
</div>
<a class="anchor" id="gad192daa61c45e0e52bd8a3acb90e48f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tcpip_poll_udp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cause a specified UDP connection to be polled. </p>
<p>This function causes uIP to poll the specified UDP connection. The function is used when the application has data that is to be sent immediately and do not wish to wait for the periodic uIP polling mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection that should be polled. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00755">755</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="process_8c_source.html#l00322">process_post()</a>.</p>

<p>Referenced by <a class="el" href="resolv_8c_source.html#l01077">resolv_get_hostname()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3cb4f212906fc7b8909a3f8938006470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udp_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach the current process to a UDP connection. </p>
<p>This function attaches the current process to a UDP connection. Each UDP connection must have a process attached to it in order for the process to be able to receive and send data over the connection. Additionally, this function can add a pointer with connection state to the connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>A pointer to the UDP connection.</td></tr>
    <tr><td class="paramname">appstate</td><td>An opaque pointer that will be passed to the process whenever an event occurs on the connection. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00259">259</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip_8h_source.html#l01396">uip_udp_conn::appstate</a>.</p>

</div>
</div>
<a class="anchor" id="gabd0394436a6f855ec38871cacd01f8c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a>* udp_broadcast_new </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new UDP broadcast connection. </p>
<p>This function creates a new (link-local) broadcast UDP connection to a specified port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00279">279</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip-nd6_8c_source.html#l00115">addr</a>, <a class="el" href="tcpip_8h_source.html#l00261">udp_bind</a>, <a class="el" href="tcpip_8c_source.html#l00265">udp_new()</a>, and <a class="el" href="uip_8h_source.html#l02024">uip_create_linklocal_allnodes_mcast</a>.</p>

</div>
</div>
<a class="anchor" id="ga50d09ad4a7c853480f694068137f2d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structuip__udp__conn.html">uip_udp_conn</a>* udp_new </td>
          <td>(</td>
          <td class="paramtype">const uip_ipaddr_t *&#160;</td>
          <td class="paramname"><em>ripaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>appstate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new UDP connection. </p>
<p>This function creates a new UDP connection with the specified remote endpoint.</p>
<dl class="section note"><dt>Note</dt><dd>The port number must be provided in network byte order so a conversion with <a class="el" href="group__uipconvfunc.html#ga703ee949a28cb00b5f8ee54bfe664e8d" title="Convert 16-bit quantity from host byte order to network byte order. ">UIP_HTONS()</a> usually is necessary.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__tcpip.html#ga6afb919d5d0923a55252eeb46caf58d6" title="Bind a UDP connection to a local port. ">udp_bind()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ripaddr</td><td>Pointer to the IP address of the remote host. </td></tr>
    <tr><td class="paramname">port</td><td>Port number in network byte order. </td></tr>
    <tr><td class="paramname">appstate</td><td>Pointer to application defined data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the newly created connection, or NULL if memory could not be allocated for the connection. </dd></dl>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00265">265</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>References <a class="el" href="uip_8h_source.html#l01396">uip_udp_conn::appstate</a>, and <a class="el" href="uip6_8c_source.html#l00541">uip_udp_new()</a>.</p>

<p>Referenced by <a class="el" href="coap-uip_8c_source.html#l00384">coap_sendto()</a>, <a class="el" href="resolv_8c_source.html#l01077">resolv_get_hostname()</a>, <a class="el" href="simple-udp_8c_source.html#l00104">simple_udp_register()</a>, and <a class="el" href="tcpip_8c_source.html#l00279">udp_broadcast_new()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga3e1d02b632991947fdf381d334afdbf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_event_t tcpip_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The uIP event. </p>
<p>This event is posted to a process whenever a uIP event has occurred. </p>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00066">66</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>Referenced by <a class="el" href="coap-uip_8c_source.html#l00384">coap_sendto()</a>, <a class="el" href="resolv_8c_source.html#l01077">resolv_get_hostname()</a>, <a class="el" href="simple-udp_8c_source.html#l00104">simple_udp_register()</a>, and <a class="el" href="tcpip_8c_source.html#l00763">tcpip_poll_tcp()</a>.</p>

</div>
</div>
<a class="anchor" id="gada1a3e7375e1c1f67e8d7be54a53f419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_event_t tcpip_icmp6_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ICMP6 event. </p>
<p>This event is posted to a process whenever a uIP ICMP event has occurred. </p>

<p>Definition at line <a class="el" href="tcpip_8c_source.html#l00068">68</a> of file <a class="el" href="tcpip_8c_source.html">tcpip.c</a>.</p>

<p>Referenced by <a class="el" href="tcpip_8c_source.html#l00305">tcpip_icmp6_call()</a>, and <a class="el" href="tcpip_8c_source.html#l00763">tcpip_poll_tcp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Apr 28 2018 13:00:47 for Contiki-NG by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
