<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Contiki-NG: Protothreads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doc-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki-NG
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Protothreads<div class="ingroups"><a class="el" href="a01393.html">Threads and processes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Protothreads are a type of lightweight stackless threads designed for severly memory constrained systems such as deeply embedded systems or sensor network nodes.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a01376"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01376.html">Local continuations</a></td></tr>
<tr class="memdesc:a01376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local continuations form the basis for implementing protothreads. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01380"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01380.html">Protothread semaphores</a></td></tr>
<tr class="memdesc:a01380"><td class="mdescLeft">&#160;</td><td class="mdescRight">This module implements counting semaphores on top of protothreads. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:a01115"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01115.html">pt.h</a></td></tr>
<tr class="memdesc:a01115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protothreads implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization</h2></td></tr>
<tr class="memitem:gae6bae7dc0225468c8a5ac269df549892"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gae6bae7dc0225468c8a5ac269df549892">PT_INIT</a>(pt)</td></tr>
<tr class="memdesc:gae6bae7dc0225468c8a5ac269df549892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a protothread.  <a href="#gae6bae7dc0225468c8a5ac269df549892">More...</a><br/></td></tr>
<tr class="separator:gae6bae7dc0225468c8a5ac269df549892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Declaration and definition</h2></td></tr>
<tr class="memitem:ga3d4c8bd4aada659eb34f5d2ffd3e7901"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga3d4c8bd4aada659eb34f5d2ffd3e7901">PT_THREAD</a>(name_args)</td></tr>
<tr class="memdesc:ga3d4c8bd4aada659eb34f5d2ffd3e7901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of a protothread.  <a href="#ga3d4c8bd4aada659eb34f5d2ffd3e7901">More...</a><br/></td></tr>
<tr class="separator:ga3d4c8bd4aada659eb34f5d2ffd3e7901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f1c8b9f87df406e19dfe19a2995130"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga92f1c8b9f87df406e19dfe19a2995130">PT_BEGIN</a>(pt)</td></tr>
<tr class="memdesc:ga92f1c8b9f87df406e19dfe19a2995130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare the start of a protothread inside the C function implementing the protothread.  <a href="#ga92f1c8b9f87df406e19dfe19a2995130">More...</a><br/></td></tr>
<tr class="separator:ga92f1c8b9f87df406e19dfe19a2995130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24910691cbfb65d2a208e758d12b504"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gaa24910691cbfb65d2a208e758d12b504">PT_END</a>(pt)</td></tr>
<tr class="memdesc:gaa24910691cbfb65d2a208e758d12b504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declare the end of a protothread.  <a href="#gaa24910691cbfb65d2a208e758d12b504">More...</a><br/></td></tr>
<tr class="separator:gaa24910691cbfb65d2a208e758d12b504"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Blocked wait</h2></td></tr>
<tr class="memitem:ga99e43010ec61327164466aa2d902de45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga99e43010ec61327164466aa2d902de45">PT_WAIT_UNTIL</a>(pt, condition)</td></tr>
<tr class="memdesc:ga99e43010ec61327164466aa2d902de45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block and wait until condition is true.  <a href="#ga99e43010ec61327164466aa2d902de45">More...</a><br/></td></tr>
<tr class="separator:ga99e43010ec61327164466aa2d902de45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad14bbbf092b90aa0a5a4f9169504a8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gaad14bbbf092b90aa0a5a4f9169504a8d">PT_WAIT_WHILE</a>(pt, cond)</td></tr>
<tr class="memdesc:gaad14bbbf092b90aa0a5a4f9169504a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block and wait while condition is true.  <a href="#gaad14bbbf092b90aa0a5a4f9169504a8d">More...</a><br/></td></tr>
<tr class="separator:gaad14bbbf092b90aa0a5a4f9169504a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hierarchical protothreads</h2></td></tr>
<tr class="memitem:ga2f8f70c30b9ee08a103fbd69a4365c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga2f8f70c30b9ee08a103fbd69a4365c4c">PT_WAIT_THREAD</a>(pt, thread)</td></tr>
<tr class="memdesc:ga2f8f70c30b9ee08a103fbd69a4365c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block and wait until a child protothread completes.  <a href="#ga2f8f70c30b9ee08a103fbd69a4365c4c">More...</a><br/></td></tr>
<tr class="separator:ga2f8f70c30b9ee08a103fbd69a4365c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e97a0b4d5cc7764d8e19758f5da53ae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga9e97a0b4d5cc7764d8e19758f5da53ae">PT_SPAWN</a>(pt, child, thread)</td></tr>
<tr class="memdesc:ga9e97a0b4d5cc7764d8e19758f5da53ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a child protothread and wait until it exits.  <a href="#ga9e97a0b4d5cc7764d8e19758f5da53ae">More...</a><br/></td></tr>
<tr class="separator:ga9e97a0b4d5cc7764d8e19758f5da53ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Exiting and restarting</h2></td></tr>
<tr class="memitem:gacd3ac045f0a4ae63412e3b3d8780e8ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gacd3ac045f0a4ae63412e3b3d8780e8ab">PT_RESTART</a>(pt)</td></tr>
<tr class="memdesc:gacd3ac045f0a4ae63412e3b3d8780e8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the protothread.  <a href="#gacd3ac045f0a4ae63412e3b3d8780e8ab">More...</a><br/></td></tr>
<tr class="separator:gacd3ac045f0a4ae63412e3b3d8780e8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905451249dca72ce0385bf2a9ff178ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga905451249dca72ce0385bf2a9ff178ee">PT_EXIT</a>(pt)</td></tr>
<tr class="memdesc:ga905451249dca72ce0385bf2a9ff178ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit the protothread.  <a href="#ga905451249dca72ce0385bf2a9ff178ee">More...</a><br/></td></tr>
<tr class="separator:ga905451249dca72ce0385bf2a9ff178ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Calling a protothread</h2></td></tr>
<tr class="memitem:gafa82b860a64b67d25ab3abc21811896f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gafa82b860a64b67d25ab3abc21811896f">PT_SCHEDULE</a>(f)</td></tr>
<tr class="memdesc:gafa82b860a64b67d25ab3abc21811896f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a protothread.  <a href="#gafa82b860a64b67d25ab3abc21811896f">More...</a><br/></td></tr>
<tr class="separator:gafa82b860a64b67d25ab3abc21811896f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Yielding from a protothread</h2></td></tr>
<tr class="memitem:ga155cba6121323726d02c00284428fed6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#ga155cba6121323726d02c00284428fed6">PT_YIELD</a>(pt)</td></tr>
<tr class="memdesc:ga155cba6121323726d02c00284428fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield from the current protothread.  <a href="#ga155cba6121323726d02c00284428fed6">More...</a><br/></td></tr>
<tr class="separator:ga155cba6121323726d02c00284428fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c821e3a388615528efda9d23c7d115"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01396.html#gae3c821e3a388615528efda9d23c7d115">PT_YIELD_UNTIL</a>(pt, cond)</td></tr>
<tr class="memdesc:gae3c821e3a388615528efda9d23c7d115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yield from the protothread until a condition occurs.  <a href="#gae3c821e3a388615528efda9d23c7d115">More...</a><br/></td></tr>
<tr class="separator:gae3c821e3a388615528efda9d23c7d115"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Protothreads are a type of lightweight stackless threads designed for severly memory constrained systems such as deeply embedded systems or sensor network nodes. </p>
<p>Protothreads provides linear code execution for event-driven systems implemented in C. Protothreads can be used with or without an RTOS.</p>
<p>Protothreads are a extremely lightweight, stackless type of threads that provides a blocking context on top of an event-driven system, without the overhead of per-thread stacks. The purpose of protothreads is to implement sequential flow of control without complex state machines or full multi-threading. Protothreads provides conditional blocking inside C functions.</p>
<p>The advantage of protothreads over a purely event-driven approach is that protothreads provides a sequential code structure that allows for blocking functions. In purely event-driven systems, blocking must be implemented by manually breaking the function into two pieces - one for the piece of code before the blocking call and one for the code after the blocking call. This makes it hard to use control structures such as if() conditionals and while() loops.</p>
<p>The advantage of protothreads over ordinary threads is that a protothread does not require a separate stack. In memory constrained systems, the overhead of allocating multiple stacks can consume large amounts of the available memory. In contrast, each protothread only requires between two and twelve bytes of state, depending on the architecture.</p>
<dl class="section note"><dt>Note</dt><dd>Because protothreads do not save the stack context across a blocking call, <b>local variables are not preserved when the protothread blocks</b>. This means that local variables should be used with utmost care - <b>if in doubt, do not use local variables inside a protothread!</b></dd></dl>
<p>Main features: </p>
<pre class="fragment">- No machine specific code - the protothreads library is pure C

- Does not use error-prone functions such as longjmp()

- Very small RAM overhead - only two bytes per protothread

- Can be used with or without an OS

- Provides blocking wait without full multi-threading or
  stack-switching
</pre><p>Examples applications: </p>
<pre class="fragment">- Memory constrained systems

- Event-driven protocol stacks

- Deeply embedded systems

- Sensor network nodes
</pre><p>The protothreads API consists of four basic operations: initialization: <a class="el" href="a01396.html#gae6bae7dc0225468c8a5ac269df549892" title="Initialize a protothread. ">PT_INIT()</a>, execution: <a class="el" href="a01396.html#ga92f1c8b9f87df406e19dfe19a2995130" title="Declare the start of a protothread inside the C function implementing the protothread. ">PT_BEGIN()</a>, conditional blocking: <a class="el" href="a01396.html#ga99e43010ec61327164466aa2d902de45" title="Block and wait until condition is true. ">PT_WAIT_UNTIL()</a> and exit: <a class="el" href="a01396.html#gaa24910691cbfb65d2a208e758d12b504" title="Declare the end of a protothread. ">PT_END()</a>. On top of these, two convenience functions are built: reversed condition blocking: <a class="el" href="a01396.html#gaad14bbbf092b90aa0a5a4f9169504a8d" title="Block and wait while condition is true. ">PT_WAIT_WHILE()</a> and protothread blocking: <a class="el" href="a01396.html#ga2f8f70c30b9ee08a103fbd69a4365c4c" title="Block and wait until a child protothread completes. ">PT_WAIT_THREAD()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01396.html">Protothreads API documentation</a></dd></dl>
<p>The protothreads library is released under a BSD-style license that allows for both non-commercial and commercial usage. The only requirement is that credit is given.</p>
<h1><a class="anchor" id="authors"></a>
Authors</h1>
<p>The protothreads library was written by Adam Dunkels <a href="#" onclick="location.href='mai'+'lto:'+'ada'+'m@'+'sic'+'s.'+'se'; return false;">adam@<span style="display: none;">.nosp@m.</span>sics<span style="display: none;">.nosp@m.</span>.se</a> with support from Oliver Schmidt <a href="#" onclick="location.href='mai'+'lto:'+'ol.'+'sc'+'@we'+'b.'+'de'; return false;">ol.sc<span style="display: none;">.nosp@m.</span>@web<span style="display: none;">.nosp@m.</span>.de</a>.</p>
<h1><a class="anchor" id="pt-desc"></a>
Protothreads</h1>
<p>Protothreads are a extremely lightweight, stackless threads that provides a blocking context on top of an event-driven system, without the overhead of per-thread stacks. The purpose of protothreads is to implement sequential flow of control without using complex state machines or full multi-threading. Protothreads provides conditional blocking inside a C function.</p>
<p>In memory constrained systems, such as deeply embedded systems, traditional multi-threading may have a too large memory overhead. In traditional multi-threading, each thread requires its own stack, that typically is over-provisioned. The stacks may use large parts of the available memory.</p>
<p>The main advantage of protothreads over ordinary threads is that protothreads are very lightweight: a protothread does not require its own stack. Rather, all protothreads run on the same stack and context switching is done by stack rewinding. This is advantageous in memory constrained systems, where a stack for a thread might use a large part of the available memory. A protothread only requires only two bytes of memory per protothread. Moreover, protothreads are implemented in pure C and do not require any machine-specific assembler code.</p>
<p>A protothread runs within a single C function and cannot span over other functions. A protothread may call normal C functions, but cannot block inside a called function. Blocking inside nested function calls is instead made by spawning a separate protothread for each potentially blocking function. The advantage of this approach is that blocking is explicit: the programmer knows exactly which functions that block that which functions the never blocks.</p>
<p>Protothreads are similar to asymmetric co-routines. The main difference is that co-routines uses a separate stack for each co-routine, whereas protothreads are stackless. The most similar mechanism to protothreads are Python generators. These are also stackless constructs, but have a different purpose. Protothreads provides blocking contexts inside a C function, whereas Python generators provide multiple exit points from a generator function.</p>
<h1><a class="anchor" id="pt-autovars"></a>
Local variables</h1>
<dl class="section note"><dt>Note</dt><dd>Because protothreads do not save the stack context across a blocking call, local variables are not preserved when the protothread blocks. This means that local variables should be used with utmost care - if in doubt, do not use local variables inside a protothread!</dd></dl>
<h1><a class="anchor" id="pt-scheduling"></a>
Scheduling</h1>
<p>A protothread is driven by repeated calls to the function in which the protothread is running. Each time the function is called, the protothread will run until it blocks or exits. Thus the scheduling of protothreads is done by the application that uses protothreads.</p>
<h1><a class="anchor" id="pt-impl"></a>
Implementation</h1>
<p>Protothreads are implemented using <a class="el" href="a01376.html">local continuations</a>. A local continuation represents the current state of execution at a particular place in the program, but does not provide any call history or local variables. A local continuation can be set in a specific function to capture the state of the function. After a local continuation has been set can be resumed in order to restore the state of the function at the point where the local continuation was set.</p>
<p>Local continuations can be implemented in a variety of ways:</p>
<ol type="1">
<li>by using machine specific assembler code,</li>
<li>by using standard C constructs, or</li>
<li>by using compiler extensions.</li>
</ol>
<p>The first way works by saving and restoring the processor state, except for stack pointers, and requires between 16 and 32 bytes of memory per protothread. The exact amount of memory required depends on the architecture.</p>
<p>The standard C implementation requires only two bytes of state per protothread and utilizes the C switch() statement in a non-obvious way that is similar to Duff's device. This implementation does, however, impose a slight restriction to the code that uses protothreads in that the code cannot use switch() statements itself.</p>
<p>Certain compilers has C extensions that can be used to implement protothreads. GCC supports label pointers that can be used for this purpose. With this implementation, protothreads require 4 bytes of RAM per protothread. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga92f1c8b9f87df406e19dfe19a2995130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_BEGIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare the start of a protothread inside the C function implementing the protothread. </p>
<p>This macro is used to declare the starting point of a protothread. It should be placed at the start of the function in which the protothread runs. All C statements above the <a class="el" href="a01396.html#ga92f1c8b9f87df406e19dfe19a2995130" title="Declare the start of a protothread inside the C function implementing the protothread. ">PT_BEGIN()</a> invokation will be executed each time the protothread is scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00114">114</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

<p>Referenced by <a class="el" href="a00210_source.html#l00056">PT_THREAD()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa24910691cbfb65d2a208e758d12b504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT_END</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declare the end of a protothread. </p>
<p>This macro is used for declaring that a protothread ends. It must always be used together with a matching <a class="el" href="a01396.html#ga92f1c8b9f87df406e19dfe19a2995130" title="Declare the start of a protothread inside the C function implementing the protothread. ">PT_BEGIN()</a> macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00126">126</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

<p>Referenced by <a class="el" href="a00210_source.html#l00056">PT_THREAD()</a>.</p>

</div>
</div>
<a class="anchor" id="ga905451249dca72ce0385bf2a9ff178ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_EXIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit the protothread. </p>
<p>This macro causes the protothread to exit. If the protothread was spawned by another protothread, the parent protothread will become unblocked and can continue to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00245">245</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae6bae7dc0225468c8a5ac269df549892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a protothread. </p>
<p>Initializes a protothread. Initialization must be done prior to starting to execute the protothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01396.html#ga9e97a0b4d5cc7764d8e19758f5da53ae" title="Spawn a child protothread and wait until it exits. ">PT_SPAWN()</a> </dd></dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00079">79</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

<p>Referenced by <a class="el" href="a01110_source.html#l00100">process_start()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd3ac045f0a4ae63412e3b3d8780e8ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_RESTART</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart the protothread. </p>
<p>This macro will block and cause the running protothread to restart its execution at the place of the <a class="el" href="a01396.html#ga92f1c8b9f87df406e19dfe19a2995130" title="Declare the start of a protothread inside the C function implementing the protothread. ">PT_BEGIN()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00228">228</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafa82b860a64b67d25ab3abc21811896f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_SCHEDULE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule a protothread. </p>
<p>This function schedules a protothread. The return value of the function is non-zero if the protothread is running or zero if the protothread has exited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The call to the C function implementing the protothread to be scheduled </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00270">270</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e97a0b4d5cc7764d8e19758f5da53ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_SPAWN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">child, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thread&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a child protothread and wait until it exits. </p>
<p>This macro spawns a child protothread and waits until it exits. The macro can only be used within a protothread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
    <tr><td class="paramname">child</td><td>A pointer to the child protothread's control structure. </td></tr>
    <tr><td class="paramname">thread</td><td>The child protothread with arguments </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00205">205</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d4c8bd4aada659eb34f5d2ffd3e7901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name_args</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaration of a protothread. </p>
<p>This macro is used to declare a protothread. All protothreads must be declared with this macro.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_args</td><td>The name and arguments of the C function implementing the protothread. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00099">99</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2f8f70c30b9ee08a103fbd69a4365c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_WAIT_THREAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thread&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block and wait until a child protothread completes. </p>
<p>This macro schedules a child protothread. The current protothread will block until the child protothread completes.</p>
<dl class="section note"><dt>Note</dt><dd>The child protothread must be manually initialized with the <a class="el" href="a01396.html#gae6bae7dc0225468c8a5ac269df549892" title="Initialize a protothread. ">PT_INIT()</a> function before this function is used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
    <tr><td class="paramname">thread</td><td>The child protothread with arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a01396.html#ga9e97a0b4d5cc7764d8e19758f5da53ae" title="Spawn a child protothread and wait until it exits. ">PT_SPAWN()</a> </dd></dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00191">191</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga99e43010ec61327164466aa2d902de45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_WAIT_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block and wait until condition is true. </p>
<p>This macro blocks the protothread until the specified condition is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
    <tr><td class="paramname">condition</td><td>The condition. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00147">147</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

<p>Referenced by <a class="el" href="a00210_source.html#l00056">PT_THREAD()</a>.</p>

</div>
</div>
<a class="anchor" id="gaad14bbbf092b90aa0a5a4f9169504a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_WAIT_WHILE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block and wait while condition is true. </p>
<p>This function blocks and waits while condition is true. See <a class="el" href="a01396.html#ga99e43010ec61327164466aa2d902de45" title="Block and wait until condition is true. ">PT_WAIT_UNTIL()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
    <tr><td class="paramname">cond</td><td>The condition. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00166">166</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga155cba6121323726d02c00284428fed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_YIELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield from the current protothread. </p>
<p>This function will yield the protothread, thereby allowing other processing to take place in the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00289">289</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae3c821e3a388615528efda9d23c7d115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PT_YIELD_UNTIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cond&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yield from the protothread until a condition occurs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>A pointer to the protothread control structure. </td></tr>
    <tr><td class="paramname">cond</td><td>The condition. <pre class="fragment">        This function will yield the protothread, until the
        specified condition evaluates to true.</pre> </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01115_source.html#l00309">309</a> of file <a class="el" href="a01115_source.html">pt.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 6 2017 14:06:53 for Contiki-NG by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
